<#@ template debug="false" hostspecific="false" linePragmas="false" language="C#" inherits="CodeTemplateBase" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="Kari.GeneratorCore" #>

namespace <#= Project.GeneratedNamespace #>
{
    /// <summary>
    /// Encapsulates a method that does parsing.
    /// This is cleaner with concrete types instead of the generic System.Func's or
    /// even named delegates, plus these classes are mostly autogenerated. 
    /// </summary>
    public interface IValueParser<T>
    {
        ParseSummary Parse(string input, out T result);
    }

    /// <summary>
    /// Essentially, provides no-throw error handling for parsers.
    /// </summary>
    public readonly struct ParseSummary
    {
        public readonly string Message;
        public bool IsError => Message != null;
        public ParseSummary(string message) { Message = message; }
        public static readonly ParseSummary Success = new ParseSummary(null);
        public static ParseSummary TypeMismatch(string expectedTypeName, string actualInput) => new ParseSummary($"Expected input compatible with type {expectedTypeName}, got '{actualInput}'.");
    }

    
    public class BoolParser : IValueParser<bool>
    {
        public ParseSummary Parse(string input, out bool value) => Generated.Parsers.Parse(input, out value);
    }

    public class StringParser : IValueParser<string>
    {
        public ParseSummary Parse(string input, out string value) 
        {
            value = input;
            return ParseSummary.Success;   
        }
    }

    public static partial class Parsers
    {
<#  var numberTypes = new string[] 
    { 
        "int", "long", "short", "sbyte",
        "uint", "ulong", "ushort", "byte",
        "double", "float", "decimal"
    };
    var numberTypesPascal = new string[]
    {
        "Int", "Long", "Short", "SByte",
        "UInt", "ULong", "UShort", "Byte",
        "Double", "Float", "Decimal"
    };
    
    for (int i = 0; i < numberTypes.Length; i++)
    {
        string type = numberTypes[i];
        string typePascal = numberTypesPascal[i];
        string parserName = $"{typePascal}Parser"; #>
        public class <#= parserName #> : IValueParser<<#= type #>>
        {
            public ParseSummary Parse(string input, out <#= type #> value) => Parsers.Parse(input, out value);
        }
        public static readonly <#= parserName #> <#= typePascal #> = new <#= parserName #> ();

        public static ParseSummary Parse(this string input, out <#= type #> result)
        {
            if (<#= type #>.TryParse(input, out result)) 
            {
                return ParseSummary.Success;
            }

            return ParseSummary.TypeMismatch("<#= type #>", input);
        }
<#  } #>
        public static readonly BoolParser Bool = new BoolParser();
        public static readonly StringParser String = new StringParser();

        public static ParseSummary Parse(this string input, out bool result)
        {
            if (string.Compare(input, "TRUE", ignoreCase: true) == 0) 
            {
                result = true;
                return ParseSummary.Success;
            }

            if (string.Compare(input, "FALSE", ignoreCase: true) == 0) 
            {
                result = false;
                return ParseSummary.Success;
            }

            result = default;
            return ParseSummary.TypeMismatch("bool", input);
        }
    }
}
