using System.IO;
using System.Linq;
using Kari.GeneratorCore;
using Kari.GeneratorCore.Workflow;
using Kari.Utils;
using Microsoft.CodeAnalysis.CSharp;

namespace Kari.Generator
{
    internal class PluginFileTemplates
    {
        private Logger _logger = new Logger("Plugin Templates");

        public void WriteNewPlugin(string newPluginPath)
        {
            if (File.Exists(newPluginPath))
            {
                _logger.LogError($"The path for the new plugin {newPluginPath} must be an empty directory, got a file instead.");
                return;
            }

            string pluginName = new DirectoryInfo(newPluginPath).Name;
            if (pluginName[0] < 'A' || pluginName[0] > 'Z') 
            {
                _logger.LogError($"The plugin name `{pluginName}` must start with a capital letter (if you want lower case letters, I may add a `notPedantic` option).");
            }
            if (!SyntaxFacts.IsValidIdentifier(pluginName))
            {
                _logger.LogError($"The plugin name `{pluginName}` must be a valid identifier.");
            }
            if (Logger.AnyLoggerHasErrors)
                return;

            if (!Directory.Exists(newPluginPath))
            {
                Directory.CreateDirectory(newPluginPath);
            }
            else if (Directory.EnumerateFileSystemEntries(newPluginPath).Any())
            {
                _logger.LogError($"The plugin directory {newPluginPath} is not empty.");
                return;
            }
            
            File.WriteAllText(
                Path.Combine(newPluginPath, $"{pluginName}Administrator.cs"),
                PluginFileTemplates.ADMINISTRATOR_TEMPLATE(pluginName));
            
            File.WriteAllText(
                Path.Combine(newPluginPath, $"{pluginName}Analyzer.cs"),
                PluginFileTemplates.ANALYZER_TEMPLATE(pluginName));

            File.WriteAllText(
                Path.Combine(newPluginPath, $"{pluginName}Annotations.cs"),
                PluginFileTemplates.ANNOTATIONS_TEMPLATE(pluginName));
                
            File.WriteAllText(
                Path.Combine(newPluginPath, $"{pluginName}.csproj"),
                PluginFileTemplates.CSPROJ_TEMPLATE(pluginName));

            string templatesPath = Path.Combine(newPluginPath, "Templates");
            Directory.CreateDirectory(templatesPath);

            File.WriteAllText(
                Path.Combine(templatesPath, $"{pluginName}Template.tt"),
                PluginFileTemplates.TEMPLATE_TEMPLATE(pluginName));
        }

        private const string TEMPLATE_NOTICE = @"// Template file generated by Kari. Feel free to change it or remove this message.";
        private static string ADMINISTRATOR_TEMPLATE(string pluginName) => TEMPLATE_NOTICE + $@"
using System.Threading.Tasks;
using Kari.GeneratorCore.Workflow;

namespace Kari.Plugins.{pluginName}
{{
    // The plugin interface to Kari.
    // Kari will call methods of this class to analyze and then generate code.
    public class {pluginName}Administrator : IAdministrator
    {{
        public {pluginName}Analyzer[] _analyzers;
        
        // Called after all of the projects have been loaded
        public void Initialize()
        {{
            AnalyzerMaster.Initialize(ref _analyzers);
            var logger = new Logger(""{pluginName} Plugin"");
            {pluginName}Symbols.Initialize(logger);
        }}
        
        // Called when it is time to find (""collect"") the types and methods you need to analyze.
        // At this stage, info objects are created and stored, 
        // containing the final data needed to generate the output.
        public Task Collect()
        {{
            return AnalyzerMaster.CollectAsync(_analyzers);
        }}
        // Called to generate code. The name of the files can be anything.
        public Task Generate()
        {{
            return Task.WhenAll(
                AnalyzerMaster.GenerateAsync(_analyzers, ""{pluginName}.cs"", new {pluginName}Template()),
                // Write the attributes to an acessible file.
                MasterEnvironment.Instance.CommonPseudoProject.WriteFileAsync(""{pluginName}Annotations.cs"", GetAnnotations())
            );
        }}
        
        public string GetAnnotations() => Dummy{pluginName}Annotations.Text;
    }}
}}
";

        private static string ANALYZER_TEMPLATE(string pluginName) => TEMPLATE_NOTICE + $@"
using System.Collections.Generic;
using Kari.GeneratorCore.Workflow;
using Microsoft.CodeAnalysis;

namespace Kari.Plugins.{pluginName}
{{
    // An analyzer will be created per project. 
    // It manages collecting specific information with a single project as input.
    public class {pluginName}Analyzer : IAnalyzer
    {{
        // Keep this public for it to be acessible via the template.
        public readonly List<{pluginName}Info> _infos = new List<{pluginName}Info>();
        public void Collect(ProjectEnvironment environment)
        {{
            foreach (var type in environment.TypesWithAttributes)
            {{
                if (type.HasAttribute({pluginName}Symbols.{pluginName}Attribute.symbol))
                {{
                    _infos.Add(new {pluginName}Info(type));
                }}
            }}
        }}
    }}
    // Store information in such structs/classes
    public readonly struct {pluginName}Info
    {{
        public readonly INamedTypeSymbol Symbol;
        public {pluginName}Info(INamedTypeSymbol symbol)
        {{
            Symbol = symbol;
        }}
    }}
}}
";

        private static string TEMPLATE_TEMPLATE(string pluginName) => $@"<#@ template debug=""false"" hostspecific=""false"" linePragmas=""false"" language=""C#"" inherits=""CodeGenerator<{pluginName}Analyzer>"" #>
<#@ assembly name=""System.Core"" #>
<#@ import namespace=""Kari.GeneratorCore"" #>
<#@ import namespace=""Kari.Plugins.{pluginName}"" #>
<#  // Returing null implies no output should be generated for the given template
    // `m` here is the analyzer instance for the current project.
    if (m._infos.Count == 0) return null;  #>
namespace <#= Project.GeneratedNamespaceName #>
{{
<#  // IMPORTANT: 
    // Put the usings inside the namespace, because Kari may do single-file output
    // in which case the generated code might be messed up if you pull in any symbols.
    // Try to scope things as much as possible and fully-qualify names where appropriate. #>
    using System;
    public static class MarkedTypes
    {{
<#  foreach (var info in m._infos)
    {{ #>
        public const string <#= info.Symbol.Name #> = ""<#= info.Symbol.Name #>"";
<#  }} #>
    }}
}}
";

        private static string ANNOTATIONS_TEMPLATE(string pluginName) => TEMPLATE_NOTICE + $@"
// This file should be included almost as-is in the generated output.
// The text version of this file and the helpers for the attributes defined here are available in the
// {pluginName}Annotations.Generated.cs version of this file.
namespace Kari.Plugins.{pluginName}
{{
    // It is important to import things inside the namespace.
    // Obviously, you cannot import Kari specific things or things defined in your other files, 
    // unless you also export the source code from those files.
    using System;
    using System.Diagnostics;
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    [Conditional(""CodeGeneration"")]
    public class {pluginName}Attribute : Attribute
    {{
    }}
    // You may include things besides attributes in this file, 
    // if you want them shared between your and your consumer's project.
    public interface IExample
    {{
    }}
}}
";

        private static string CSPROJ_TEMPLATE(string pluginName) => $@"<Project Sdk=""Microsoft.NET.Sdk"">
  <!-- Has to point to Kari's root Plugin.props --> 
  <Import Project=""../Plugin.props"" />
  <PropertyGroup>
    <AssemblyName>Kari.Plugins.{pluginName}</AssemblyName>
  </PropertyGroup>
</Project>
";
    }
}
