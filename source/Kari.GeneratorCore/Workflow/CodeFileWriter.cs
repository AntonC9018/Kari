using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Kari.GeneratorCore.Workflow
{
    // Writing is done to string builders
    // -> Contents of string builders are checked against the files in the file system
    // -> Builders are flushed only if the contents differ

    // So, a dictionary of lists of code builders.
    // Per project.
    // Then they are flushed into the file.
    // Sort the lists by the plugin name that produced it.

    /// <summary>
    /// Such a thing.
    /// </summary>
    public readonly struct CodeFragment : IComparable<CodeFragment>
    {
        /// <summary>
        /// The identification name of the entity that has produced the content.
        /// Using the class name is ok.
        /// </summary>
        public string NameHint { get; init; }
        public StringBuilder StringBuilder { get; init; } // maybe StringBuilder

        public int CompareTo(CodeFragment other)
        {
            return NameHint.CompareTo(other.NameHint);    
        }
    }

    /// <summary>
    /// Provides an abstraction for writing code files to a given output file.
    /// The file may be written in a different folder or file than requested.
    /// See the implementing classes for the different available options.
    /// </summary>
    public interface IFileWriter : IDisposable
    {
        /// <summary>
        /// Returns a new writer, scoped to the generated output file/directory 
        /// of the given project base directory.
        /// </summary>
        IFileWriter GetWriter(string projectDirectory);

        /// <summary>
        /// Writes the given text to a file.
        /// The `fileNameHint` parameter indicates the desired file name, but the function
        /// gives no guarantees of the actual file the text will be written to.
        /// </summary>
        Task WriteCodeFile(string fileNameHint, string text);

        /// <summary>
        /// Destroys all files that were or would have been generated by the given file writer.
        /// </summary>
        void DeleteOutput();

        /// <summary>
        /// </summary>
        Task Flush();
    }

    /// <summary>
    /// Data common to all writers, such as the header and the footer of the generated files.
    /// </summary>
    public static class FileWriterCommon
    {
        public static readonly Encoding NoBomUtf8 = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);

        public const string Header = @"// <auto-generated>
// This file has been autogenerated by Kari.
// </auto-generated>

#pragma warning disable
";

        public const string Footer = "#pragma warning restore";

        public static void InitializeGeneratedDirectory(string directory)
        {
            Directory.CreateDirectory(directory);
            var gitignore = Path.Combine(directory, ".gitignore");
            if (!File.Exists(gitignore) && !Directory.Exists(gitignore))
            {
                File.WriteAllText(gitignore, "*\n!.gitignore");
            }
        }
    }

    /// <summary>
    /// Dumps all output in a single file, indicated by `MasterEnvironment.Instance.GeneratedDirectorySuffix`.
    /// Must be initialized after you have set the global MasterEnvironment instance.
    /// </summary>
    public class SingleCodeFileWriter : OneFilePerProjectFileWriter
    {
        public SingleCodeFileWriter(string generatedFilePath) : base(generatedFilePath)
        {
        }

        // Works the same as OneFilePerProjectFileWriter, but returns the first instance every time.
        // That instance will be set to the output file of the RootProject.
        public override IFileWriter GetWriter(string generatedFilePath)
        {
            return this;
        }
    }

    /// <summary>
    /// Dumps the output in a single file, unique per identified project.
    /// The output file is determined by `MasterEnvironment.Instance.GeneratedDirectorySuffix`.
    /// </summary>
    public class OneFilePerProjectFileWriter : IFileWriter, IDisposable
    {
        private readonly string _filePath;
        private StreamWriter _file;
        private SemaphoreSlim _semaphore;

        public OneFilePerProjectFileWriter(string generatedFilePath)
        {
            _filePath = generatedFilePath;
            _semaphore = new SemaphoreSlim(initialCount: 1, maxCount: 1);
            var dirName = Path.GetDirectoryName(_filePath);
            FileWriterCommon.InitializeGeneratedDirectory(dirName);
        }

        private Task OpenFile()
        {
            _file = new StreamWriter(_filePath, append: false, FileWriterCommon.NoBomUtf8);
            return _file.WriteLineAsync(FileWriterCommon.Header);
        }

        public void Dispose()
        {
            if (_file is null) 
                return;
            _file.WriteLine(FileWriterCommon.Footer);
            _file.Flush();
            _file.Close();
            _file = null;
        }

        public async Task WriteCodeFile(string fileNameHint, string text)
        {
            await _semaphore.WaitAsync();
            try
            {
                if (_file is null) 
                    await OpenFile();
                await _file.WriteLineAsync("// " + fileNameHint);
                await _file.WriteLineAsync(text);
            }
            catch
            {
                _semaphore.Release();
            }
        }

        public virtual IFileWriter GetWriter(string filePath)
        {
            return new OneFilePerProjectFileWriter(filePath);
        }

        public void DeleteOutput()
        {
            if (_file != null) _file.Close();
            if (File.Exists(_filePath))
            {
                File.Delete(_filePath);
            }
        }
    }

    /// <summary>
    /// Dumps all output in the respective separate files, conforming to the requested file name.
    /// The output is written to the output folder of the specified project.
    /// The output folder is determined by `MasterEnvironment.Instance.GeneratedDirectorySuffix`.
    /// </summary>
    public class SeparateCodeFileWriter : IFileWriter
    {
        private readonly string _baseFolder;

        public SeparateCodeFileWriter(string generatedDirectoryPath)
        {
            _baseFolder = Path.Combine(generatedDirectoryPath);
            FileWriterCommon.InitializeGeneratedDirectory(_baseFolder);
        }

        public void DeleteOutput()
        {
            if (Directory.Exists(_baseFolder))
            {
                foreach (var file in Directory.EnumerateFiles(_baseFolder, "*.cs", SearchOption.TopDirectoryOnly))
                {
                    File.Delete(file);
                }
            }
        }

        public void Dispose(){}

        public IFileWriter GetWriter(string projectDirectory)
        {
            return new SeparateCodeFileWriter(projectDirectory);
        }

        public void WriteCodeFile(string fileName, string text)
        {
            var path = Path.Combine(_baseFolder, fileName);
            var file = new StreamWriter(path, append: false, FileWriterCommon.NoBomUtf8);
            file.WriteLine(FileWriterCommon.Header);
            file.WriteLine(text);
            file.WriteLine(FileWriterCommon.Footer);
            file.Flush();
            file.Close();
        }
    }
}