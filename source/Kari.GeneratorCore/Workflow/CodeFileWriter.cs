using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Kari.Utils;

namespace Kari.GeneratorCore.Workflow
{
    /// <summary>
    /// Such a thing.
    /// </summary>
    public struct CodeFragment : IComparable<CodeFragment>
    {
        /// <summary>
        /// When the code is written to a file, this indicates the name of the file.
        /// The code is not guaranteed to be written into this specific file though.
        /// If another code fragment had the same name, the actual file name 
        /// is going to be appended `_NameHint` to.
        /// </summary>
        public string FileNameHint { get; init; }

        /// <summary>
        /// The identification name of the entity that has produced the content.
        /// Using the class name is ok.
        /// </summary>
        public string NameHint { get; init; }

        /// <summary>
        /// </summary>
        public ArraySegment<byte> Bytes { get; init; }

        /// <summary>
        /// </summary>
        public bool AreBytesRentedFromArrayPool { get; init; }

        public static CodeFragment CreateFromBuilder(string fileNameHint, string nameHint, CodeBuilder builder)
        {
            return new CodeFragment
            {
                FileNameHint = fileNameHint,
                NameHint = nameHint,
                Bytes = builder.AsArraySegment(),
                AreBytesRentedFromArrayPool = true,
            };
        }

        public int CompareTo(CodeFragment other)
        {
            return NameHint.CompareTo(other.NameHint);    
        }
        
        public string GetLongName()
        {
            return FileNameHint + "__" + NameHint;
        }
    }

    /// <summary>
    /// Provides an abstraction for writing code files to a given output file.
    /// The file may be written in a different folder or file than requested.
    /// See the implementing classes for the different available options.
    /// </summary>
    public interface IFileWriter : IDisposable
    {
        /// <summary>
        /// Returns a new writer, scoped to the generated output file/directory 
        /// of the given project base directory.
        /// </summary>
        IFileWriter GetWriter(string projectDirectory);

        /// <summary>
        /// Writes the given text to a file.
        /// The `fileNameHint` parameter indicates the desired file name, but the function
        /// gives no guarantees of the actual file the text will be written to.
        /// </summary>
        Task WriteCodeFile(string fileNameHint, string text);

        /// <summary>
        /// Destroys all files that were or would have been generated by the given file writer.
        /// </summary>
        void DeleteOutput();

        /// <summary>
        /// </summary>
        Task Flush();
    }

    /// <summary>
    /// Data common to all writers, such as the header and the footer of the generated files.
    /// </summary>
    public static class CodeFileCommon
    {
        public const string HeaderString = @"// <auto-generated>
// This file has been autogenerated by Kari.
// </auto-generated>

#pragma warning disable

";
        public static readonly byte[] HeaderBytes = Encoding.UTF8.GetBytes(HeaderString); 

        public const string FooterString = "#pragma warning restore\r\n";
        public static readonly byte[] FooterBytes = Encoding.UTF8.GetBytes(FooterString); 

        public static void InitializeGeneratedDirectory(string directory)
        {
            Directory.CreateDirectory(directory);
            var gitignore = Path.Combine(directory, ".gitignore");
            if (!File.Exists(gitignore) && !Directory.Exists(gitignore))
            {
                File.WriteAllText(gitignore, "*\n!.gitignore");
            }
        }
    }
}