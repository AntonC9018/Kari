<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ output extension=".cs" #>
<#@ parameter name="AnnotationsPath" type="string" #>
<#	
	var absolutePath = AnnotationsPath;
	var classname = Path.GetFileNameWithoutExtension(absolutePath);
	var attributesText = File.ReadAllText(absolutePath, Encoding.UTF8);
	var attributesTextEscaped = attributesText.Replace("\"", "\"\"").Replace("internal", "public"); 

	// literally the first line has the namespace declaration
	string lambda()
	{
		int nspaceIndex = attributesText.IndexOf("namespace");
		if (nspaceIndex == -1) 
		{
			return "namespace Dummy";
		}

		int bracketIndex = attributesText.IndexOf('{', nspaceIndex + "namespace".Length);
		if (bracketIndex == -1)
		{
			return attributesText;
		}

		var n = attributesText.Substring(nspaceIndex, bracketIndex - nspaceIndex);
		return n.Replace("\r\n", "").Replace("\n", "");
	}

	string namespaceDeclaration = lambda();

	string ReplaceLastOccurrence(string source, string find, string replace)
	{
		int place = source.LastIndexOf(find);
		if (place == -1) return source;
		return source.Remove(place, find.Length).Insert(place, replace);
	}
	var symbolsClass = ReplaceLastOccurrence(classname, "Annotations", "Symbols");
	var attributeClassRegex = new Regex(@"class\s+([a-zA-Z]+Attribute)\s*:\s*[a-zA-Z.]*Attribute");
	var attributeClassNames = attributeClassRegex.Matches(attributesText).Select(m => m.Groups[1].Value);
#>
<#= namespaceDeclaration #> 
{
	using Kari.GeneratorCore.Workflow;
	using Kari.Utils;

	internal static class Dummy<#= classname #>
	{
		internal const string Text = @"<#= attributesTextEscaped #>
";
	}

	internal static partial class <#= symbolsClass #>
    {
<# 	foreach (var attibuteClassName in attributeClassNames) 
	{ #>
        internal static AttributeSymbolWrapper<<#= attibuteClassName #>> <#= attibuteClassName #> { get; private set; } 
<#	} #>

        internal static void Initialize(Logger logger) 
        { 
            var compilation = MasterEnvironment.Instance.Compilation;
<# 	foreach (var attibuteClassName in attributeClassNames) 
	{ #>
			<#= attibuteClassName #> = new AttributeSymbolWrapper<<#= attibuteClassName #>>(compilation, logger);
<#	} #>
        }
    }
}