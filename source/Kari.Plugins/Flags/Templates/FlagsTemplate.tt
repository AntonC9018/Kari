<#@ template debug="false" hostspecific="false" linePragmas="false" language="C#" inherits="CodeGenerator<FlagsAnalyzer>" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="Kari.GeneratorCore" #>

namespace <#= Project.GeneratedNamespace #>
{ 
    using System.Collections.Generic;
<#  foreach (var flag in m._infos)
    { #>

    public static class <#= flag.Name #>FlagsExtensions
    {
        /// <summary>
        /// Checks whether the given flags intersect with the other flags.
        /// Returns true if either of the other flags are set on the flags.
        /// To see if flags contain all of some other flags, use <c>HasFlag()</c> instead. 
        /// </summary>
        public static bool HasEitherFlag(this <#= flag.FullName #> flag1, <#= flag.FullName #> flag2)
        {
            return (flag1 & flag2) != 0;
        }

        /// <summary>
        /// Checks whether the given flags does not intersect with the other flags.
        /// Returns false if either of the other flags are set on the flags.
        /// This function does the same as negating a call to <c>HasEitherFlag()</c>.
        /// </summary>
        public static bool HasNeitherFlag(this <#= flag.FullName #> flag1, <#= flag.FullName #> flag2)
        {
            return (flag1 & flag2) == 0;
        }

        /// <summary>
        /// Modifies the given <c><#= flag.Name #></c>, setting the given flags.
        /// </summary>
        public static ref <#= flag.FullName #> Set(ref this <#= flag.FullName #> flagInitial, <#= flag.FullName #> flagToSet)
        {
            flagInitial = flagInitial | flagToSet;
            return ref flagInitial;
        }

        /// <summary>
        /// Returns a new <c><#= flag.Name #></c> with the given flags set.
        /// </summary>
        public static <#= flag.FullName #> WithSet(this <#= flag.FullName #> flagInitial, <#= flag.FullName #> flagToSet)
        {
            return flagInitial | flagToSet;
        }
        
        /// <summary>
        /// Modifies the given <c><#= flag.Name #></c> unsetting the given flags.
        /// </summary>
        public static ref <#= flag.FullName #> Unset(ref this <#= flag.FullName #> flagInitial, <#= flag.FullName #> flagToSet)
        {
            flagInitial = flagInitial & (~flagToSet);
            return ref flagInitial;
        }

        /// <summary>
        /// Returns a new <c><#= flag.Name #></c> with the given flags unset.
        /// </summary>
        public static <#= flag.FullName #> WithUnset(this <#= flag.FullName #> flagInitial, <#= flag.FullName #> flagToSet)
        {
            return flagInitial & (~flagToSet);
        }
        
        /// <summary>
        /// Modifies the given <c><#= flag.Name #></c> with the given flags set or unset, 
        /// indicated by the <c>set</c> boolean parameter.
        /// </summary>
        public static ref <#= flag.FullName #> Set(ref this <#= flag.FullName #> flagInitial, <#= flag.FullName #> flagToSet, bool set)
        {
            if (set) flagInitial = flagInitial | flagToSet;
            else     flagInitial = flagInitial & (~flagToSet);
            return ref flagInitial;
        }

        /// <summary>
        /// Returns a new <c><#= flag.Name #></c> with the given flags set or unset, 
        /// indicated by the <c>set</c> boolean parameter.
        /// </summary>
        public static <#= flag.FullName #> WithSet(this <#= flag.FullName #> flagInitial, <#= flag.FullName #> flagToSet, bool set)
        {
            if (set) return flagInitial | flagToSet;
            else     return flagInitial & (~flagToSet);
        }

        /// <summary>
        /// Returns all possible combinations of the set bits of the given <#= flag.Name #>.
        /// For example, for the input 0111 it would give 0001, 0010, 0011, 0100, 0101 and 0111.
        /// </summary>
        public static IEnumerable<<#= flag.FullName #>> GetBitCombinations(this <#= flag.FullName #> flags)
        {
            int bits = (int) flags;
            int current = (~bits + 1) & bits;

            while (current != 0)
            {
                yield return (<#= flag.FullName #>) current;
                current = (~bits + (current << 1)) & bits;
            }
        }
        
        /// <summary>
        /// Returns all individual set bits of the given <#= flag.Name #> on their positions.
        /// For example, for the input 0111 it would give 0001, 0010 and 0100.
        /// </summary>
        public static IEnumerable<<#= flag.FullName #>> GetSetBits(this <#= flag.FullName #> flags)
        {
            int bits = (int) flags;
            int current = 0;
            
            while (true)
            {
                current = (current - bits) & bits;
                if (current == 0) yield break;
                yield return (<#= flag.FullName #>) current;
            }
        }
    }
<#  } #>
}