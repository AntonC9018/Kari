using System.Collections.Generic;
using Kari.GeneratorCore;
using Kari.GeneratorCore.Workflow;
using Kari.Utils;

namespace Kari.Plugins.Terminal
{
    public partial class ParsersAnalyzer : ICollectSymbols, IGenerateCode
    {
        public string DefinitionsNamespace => TerminalAdministrator.TerminalProject.GeneratedNamespaceName;
        internal readonly List<CustomParserInfo> _customParserInfos = new List<CustomParserInfo>();
        internal readonly List<CustomParserInfo> _customParserFunctionInfos = new List<CustomParserInfo>();

        public void CollectSymbols(ProjectEnvironment environment)
        {
            string parsersFullyQualifiedClassName = ParserDatabase.GetFullyQualifiedParsersClassNameForProject(environment);

            foreach (var type in environment.TypesWithAttributes)
            {
                if (type.TryGetAttribute(ParserSymbols.ParserAttribute, environment.Logger, out var parserAttribute))
                {
                    var info = new CustomParserInfo(type, parserAttribute, parsersFullyQualifiedClassName);
                    _customParserInfos.Add(info);
                    ParserDatabase.Instance.AddParser(info);
                }
            }

            foreach (var method in environment.MethodsWithAttributes)
            {
                if (!method.IsStatic) continue;

                if (method.TryGetAttribute(ParserSymbols.ParserAttribute, environment.Logger, out var parserAttribute))
                {
                    var info = new CustomParserInfo(method, parserAttribute, parsersFullyQualifiedClassName);
                    _customParserFunctionInfos.Add(info);
                    ParserDatabase.Instance.AddParser(info);
                }
            }
        }

        internal static CodeBuilder TransformMaster()
        {
            var numberTypes = new string[] 
            { 
                "int", "long", "short", "sbyte",
                "uint", "ulong", "ushort", "byte",
                "double", "float", "decimal"
            };
            var numberTypesPascal = new string[]
            {
                "Int", "Long", "Short", "SByte",
                "UInt", "ULong", "UShort", "Byte",
                "Double", "Float", "Decimal"
            };

            var builder = CodeBuilder.Create();
            builder.AppendLine("namespace ", TerminalAdministrator.TerminalProject.GeneratedNamespaceName);
            builder.StartBlock();
            builder.Append(@"/// <summary>
    /// Encapsulates a method that does parsing.
    /// This is cleaner with concrete types instead of the generic System.Func's or
    /// even named delegates, plus these classes are mostly autogenerated. 
    /// </summary>
    public interface IValueParser<T>
    {
        ParseSummary Parse(string input, out T result);
    }

    /// <summary>
    /// Essentially, provides no-throw error handling for parsers.
    /// </summary>
    public readonly struct ParseSummary
    {
        public readonly string Message;
        public bool IsError => Message != null;
        public ParseSummary(string message) { Message = message; }
        public static readonly ParseSummary Success = new ParseSummary(null);
        public static ParseSummary TypeMismatch(string expectedTypeName, string actualInput) => new ParseSummary($""Expected input compatible with type {expectedTypeName}, got '{actualInput}'."");
    }
    
    public class BoolParser : IValueParser<bool>
    {
        public ParseSummary Parse(string input, out bool value) => Generated.Parsers.Parse(input, out value);
    }

    public class StringParser : IValueParser<string>
    {
        public ParseSummary Parse(string input, out string value) 
        {
            value = input;
            return ParseSummary.Success;   
        }
    }

    public static partial class Parsers
    {
        public static readonly BoolParser Bool = new BoolParser();
        public static readonly StringParser String = new StringParser();

        public static ParseSummary Parse(this string input, out bool result)
        {
            if (string.Compare(input, ""TRUE"", ignoreCase: true) == 0) 
            {
                result = true;
                return ParseSummary.Success;
            }

            if (string.Compare(input, ""FALSE"", ignoreCase: true) == 0) 
            {
                result = false;
                return ParseSummary.Success;
            }

            result = default;
            return ParseSummary.TypeMismatch(""bool"", input);
        }
        
                
");
            builder.IncreaseIndent();
            for (int i = 0; i < numberTypes.Length; i++)
            {
                string type = numberTypes[i];
                string typePascal = numberTypesPascal[i];
                string parserName = $"{typePascal}Parser";

                builder.AppendLine($"public class {parserName} : IValueParser<{type}>");
                builder.StartBlock();
                builder.AppendLine($"public ParseSummary Parse(string input, out {type} value) => Parsers.Parse(input, out value);");
                builder.EndBlock();

                builder.AppendLine($"public static readonly {parserName} {typePascal} = new {parserName}();");
                builder.AppendLine($"public static ParseSummary Parse(this string input, out {type} result");
                builder.StartBlock();
                builder.AppendLine($"if ({type}.TryParse(input, out result))");
                builder.IncreaseIndent();
                builder.AppendLine("return ParseSummary.Success;");
                builder.DecreaseIndent();
                builder.AppendLine($"return ParseSummary.TypeMismatch({type}input);");
                builder.EndBlock();
            }

            builder.EndBlock();
            builder.EndBlock();

            return builder;
        }

        public void GenerateCode(ProjectEnvironmentData project, ref CodeBuilder builder)
        {
            if (_customParserFunctionInfos.Count == 0 && _customParserInfos.Count == 0) 
                return;

            builder.AppendLine("namespace ", project.GeneratedNamespaceName);
            builder.StartBlock();
            builder.AppendLine("using ", DefinitionsNamespace);

            builder.AppendLine("public static partial class Parsers");
            builder.StartBlock();
            foreach (var func in _customParserFunctionInfos)
            {
                var parserName = func.Name + "Parser";
                builder.AppendLine($"public class {parserName} : IValueParser<{func.TypeName}>");
                builder.StartBlock();
                builder.AppendLine($"public ParseSummary Parse(string input, out {func.TypeName} value) => ", 
                    $"{func.FullyQualifiedName}(input, out value);");
                builder.AppendLine($"public static readonly {parserName} {func.Name} = new {parserName}();");
                builder.EndBlock();
            }
            foreach (var parser in _customParserInfos)
            {
                builder.AppendLine($"public static readonly {parser.FullyQualifiedName} {parser.Name} = new {parser.FullyQualifiedName}();");
            }
            builder.EndBlock();
        }
    }
}