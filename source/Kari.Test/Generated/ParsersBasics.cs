
// <auto-generated>
// This file has been autogenerated by Kari.
// </auto-generated>

#pragma warning disable

namespace Kari.Generated
{
    /// <summary>
    /// Encapsulates a method that does parsing.
    /// This is cleaner with concrete types instead of the generic System.Func's or
    /// even named delegates, plus these classes are mostly autogenerated. 
    /// </summary>
    public interface IValueParser<T>
    {
        ParseSummary Parse(string input, out T result);
    }

    /// <summary>
    /// Essentially, provides no-throw error handling for parsers.
    /// </summary>
    public readonly struct ParseSummary
    {
        public readonly string Message;
        public bool IsError => Message != null;
        public ParseSummary(string message) { Message = message; }
        public static readonly ParseSummary Success = new ParseSummary(null);
        public static ParseSummary TypeMismatch(string expectedTypeName, string actualInput) => new ParseSummary($"Expected input compatible with type {expectedTypeName}, got '{actualInput}'.");
    }

    
    public class BoolParser : IValueParser<bool>
    {
        public ParseSummary Parse(string input, out bool value) => Generated.Parsers.Parse(input, out value);
    }

    public class StringParser : IValueParser<string>
    {
        public ParseSummary Parse(string input, out string value) 
        {
            value = input;
            return ParseSummary.Success;   
        }
    }

    public static partial class Parsers
    {
        public class IntParser : IValueParser<int>
        {
            public ParseSummary Parse(string input, out int value) => Parsers.Parse(input, out value);
        }
        public static readonly IntParser Int = new IntParser ();

        public static ParseSummary Parse(this string input, out int result)
        {
            if (int.TryParse(input, out result)) 
            {
                return ParseSummary.Success;
            }

            return ParseSummary.TypeMismatch("int", input);
        }
        public class LongParser : IValueParser<long>
        {
            public ParseSummary Parse(string input, out long value) => Parsers.Parse(input, out value);
        }
        public static readonly LongParser Long = new LongParser ();

        public static ParseSummary Parse(this string input, out long result)
        {
            if (long.TryParse(input, out result)) 
            {
                return ParseSummary.Success;
            }

            return ParseSummary.TypeMismatch("long", input);
        }
        public class ShortParser : IValueParser<short>
        {
            public ParseSummary Parse(string input, out short value) => Parsers.Parse(input, out value);
        }
        public static readonly ShortParser Short = new ShortParser ();

        public static ParseSummary Parse(this string input, out short result)
        {
            if (short.TryParse(input, out result)) 
            {
                return ParseSummary.Success;
            }

            return ParseSummary.TypeMismatch("short", input);
        }
        public class SByteParser : IValueParser<sbyte>
        {
            public ParseSummary Parse(string input, out sbyte value) => Parsers.Parse(input, out value);
        }
        public static readonly SByteParser SByte = new SByteParser ();

        public static ParseSummary Parse(this string input, out sbyte result)
        {
            if (sbyte.TryParse(input, out result)) 
            {
                return ParseSummary.Success;
            }

            return ParseSummary.TypeMismatch("sbyte", input);
        }
        public class UIntParser : IValueParser<uint>
        {
            public ParseSummary Parse(string input, out uint value) => Parsers.Parse(input, out value);
        }
        public static readonly UIntParser UInt = new UIntParser ();

        public static ParseSummary Parse(this string input, out uint result)
        {
            if (uint.TryParse(input, out result)) 
            {
                return ParseSummary.Success;
            }

            return ParseSummary.TypeMismatch("uint", input);
        }
        public class ULongParser : IValueParser<ulong>
        {
            public ParseSummary Parse(string input, out ulong value) => Parsers.Parse(input, out value);
        }
        public static readonly ULongParser ULong = new ULongParser ();

        public static ParseSummary Parse(this string input, out ulong result)
        {
            if (ulong.TryParse(input, out result)) 
            {
                return ParseSummary.Success;
            }

            return ParseSummary.TypeMismatch("ulong", input);
        }
        public class UShortParser : IValueParser<ushort>
        {
            public ParseSummary Parse(string input, out ushort value) => Parsers.Parse(input, out value);
        }
        public static readonly UShortParser UShort = new UShortParser ();

        public static ParseSummary Parse(this string input, out ushort result)
        {
            if (ushort.TryParse(input, out result)) 
            {
                return ParseSummary.Success;
            }

            return ParseSummary.TypeMismatch("ushort", input);
        }
        public class ByteParser : IValueParser<byte>
        {
            public ParseSummary Parse(string input, out byte value) => Parsers.Parse(input, out value);
        }
        public static readonly ByteParser Byte = new ByteParser ();

        public static ParseSummary Parse(this string input, out byte result)
        {
            if (byte.TryParse(input, out result)) 
            {
                return ParseSummary.Success;
            }

            return ParseSummary.TypeMismatch("byte", input);
        }
        public class DoubleParser : IValueParser<double>
        {
            public ParseSummary Parse(string input, out double value) => Parsers.Parse(input, out value);
        }
        public static readonly DoubleParser Double = new DoubleParser ();

        public static ParseSummary Parse(this string input, out double result)
        {
            if (double.TryParse(input, out result)) 
            {
                return ParseSummary.Success;
            }

            return ParseSummary.TypeMismatch("double", input);
        }
        public class FloatParser : IValueParser<float>
        {
            public ParseSummary Parse(string input, out float value) => Parsers.Parse(input, out value);
        }
        public static readonly FloatParser Float = new FloatParser ();

        public static ParseSummary Parse(this string input, out float result)
        {
            if (float.TryParse(input, out result)) 
            {
                return ParseSummary.Success;
            }

            return ParseSummary.TypeMismatch("float", input);
        }
        public class DecimalParser : IValueParser<decimal>
        {
            public ParseSummary Parse(string input, out decimal value) => Parsers.Parse(input, out value);
        }
        public static readonly DecimalParser Decimal = new DecimalParser ();

        public static ParseSummary Parse(this string input, out decimal result)
        {
            if (decimal.TryParse(input, out result)) 
            {
                return ParseSummary.Success;
            }

            return ParseSummary.TypeMismatch("decimal", input);
        }
        public static readonly BoolParser Bool = new BoolParser();
        public static readonly StringParser String = new StringParser();

        public static ParseSummary Parse(this string input, out bool result)
        {
            if (string.Compare(input, "TRUE", ignoreCase: true) == 0) 
            {
                result = true;
                return ParseSummary.Success;
            }

            if (string.Compare(input, "FALSE", ignoreCase: true) == 0) 
            {
                result = false;
                return ParseSummary.Success;
            }

            result = default;
            return ParseSummary.TypeMismatch("bool", input);
        }
    }
}

#pragma warning restore
